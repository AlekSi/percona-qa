#!/bin/bash
# Created by Roel Van de Paar, Percona LLC

# Internal variables: Do not change! Ref below for user configurable variables
RANDOM=`date +%s%N | cut -b14-19`                             # RANDOM: Random entropy pool init. RANDOMD (below): Random number generator (6 digits)
RANDOMD=$(echo $RANDOM$RANDOM$RANDOM | sed 's/..\(......\).*/\1/')
SCRIPT_AND_PATH=$(readlink -f $0); SCRIPT=$(echo ${SCRIPT_AND_PATH} | sed 's|.*/||')
PXC=0
DOCKER=0
SCRIPT_PWD=$(cd `dirname $0` && pwd)

# User Configurable Variables
PQUERY_BIN=${SCRIPT_PWD}/pquery/pquery                        # pquery/pquery[-ps] for Percona Server runs, pquery/pquery-ms for MySQL runs, pquery/pquery-md for MariaDB runs
INFILE=${SCRIPT_PWD}/pquery/main-ms-ps-md.sql                 # Default: main-ms-ps-md.sql (mtr_to_sql.sh of all major distro's + engine mix)
OPTIONS_INFILE=${SCRIPT_PWD}/pquery/mysqld_options_ms_57.txt  # Set to the right distribution + version to match mysqld options (as generated by generate_mysqld_options.sh)
                                                              # mysqld_options_ps_56.txt, mysqld_options_ms_56.txt, mysqld_options_ms_57.txt, mysqld_options_ps_55.txt
PXC_OPTIONS_INFILE=${SCRIPT_PWD}/pquery/pxc_mysqld_options.txt # PXC wsrep mysqld options
BASEDIR=/sda/mysql-5.7.8-rc-linux-x86_64-debug                # Basedir. Note that even for PXC runs, a PS basedir is needed (we need mysql client, mysqladmin,...)
LD_LIBRARY_PATH=${BASEDIR}/lib                                # Likely does not need changing if previous line was set correctly (MS pquery build is build with MS lib)
WORKDIR=/sda/$RANDOMD                                         # Working directory. Here we keep the log files, option list, failed items
RUNDIR=/dev/shm/$RANDOMD                                      # Run directory. Here we keep a copy of the data template dir and here we do the actual mysqld runs (--datadir=...)

#docker-compose configuration
DOCKER_COMPOSE_LOC=${SCRIPT_PWD}/pxc-pquery/pquery-jenkins
DOCKER_COMPOSE_YML=${SCRIPT_PWD}/pxc-pquery/pquery-jenkins/pqueryrun/docker-compose.yml

# Improvement ideas
# * SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=0 (These likely include some of the 'SIGKILL' issues - no core but terminated)
# * SQL hashing s/t2/t1/, hex values "0x"
# * Full MTR grammar on one-liners
# * Interleave all statements with another that is likely to cause issues, for example "USE mysql"

# Security check - ensure variables are correctly set (if not, it was likely caused by altering internal variables and/or [re]moving internal variables elsewhere)
if [ "${WORKDIR}" == "/sd[a-z][/]" ]; then echo "Assert! \$WORKDIR == '${WORKDIR}' - is it missing the \$RANDOMD suffix?"; exit 1; fi
if [ "${RUNDIR}" == "/dev/shm[/]" ]; then echo "Assert! \$RUNDIR == '${RUNDIR}' - is it missing the \$RANDOMD suffix?"; exit 1; fi
if [ "$(echo ${PQUERY_BIN} | sed 's|\(^/pquery\)|\1|')" == "/pquery" ]; then echo "Assert! \$PQUERY_BIN == '${PQUERY_BIN}' - is it missing the \$SCRIPT_PWD prefix?"; exit 1; fi

# Check if this is a Docker container based run. Then check if this is a PXC run. If so, turn on Docker functionality as PXC is currently tested using Docker containers only
if [ "$1" == "docker" -o "$2" == "docker" ]; then DOCKER=1; fi
if [ "$1" == "pxc" -o "$2" == "pxc" ]; then PXC=1; DOCKER=1; fi

echoit(){
  echo "[$(date +'%T')] [$SAVED] $1"
  if [ "${WORKDIR}" != "" ]; then echo "[$(date +'%T')] [$SAVED] $1" >> /${WORKDIR}/pquery-run.log; fi
}

if [ $(ls ${LD_LIBRARY_PATH}/lib*client* 2>/dev/null | wc -l) -eq 0 ]; then
  echoit "Assert! Did not find any client library at ${LD_LIBRARY_PATH}/lib*client* !"
  exit 1
fi

if [ -r /usr/lib64/libjemalloc.so.1 ]; then 
  export LD_PRELOAD=/usr/lib64/libjemalloc.so.1; 
else 
  echoit "Assert! jemalloc not found at /usr/lib64/libjemalloc.so.1, please install it!";
  echoit "For Centos7 you can do this by: sudo yum -y install epel-release; sudo yum -y install jemalloc;"
  exit 1; 
fi
#MYEXTRA="--plugin-load=audit_log=audit_log.so;tokudb=ha_tokudb.so --init-file=${SCRIPT_PWD}/TokuDB.sql"
#MYEXTRA="--innodb_track_changed_page --innodb_file_per_table=1 --innodb_flush_method=O_DIRECT --log-bin=binlog --binlog_format=MIXED"
MYEXTRA=""
if [ "$(whoami)" == "root" ]; then MYEXTRA="--user=root ${MYEXTRA}"; fi
MYSAFE="--no-defaults --event-scheduler=ON --maximum-bulk_insert_buffer_size=1M --maximum-join_buffer_size=1M --maximum-max_heap_table_size=1M --maximum-max_join_size=1M --maximum-myisam_max_sort_file_size=1M --maximum-myisam_mmap_size=1M --maximum-myisam_sort_buffer_size=1M --maximum-optimizer_trace_max_mem_size=1M --maximum-preload_buffer_size=1M --maximum-query_alloc_block_size=1M --maximum-query_prealloc_size=1M --maximum-range_alloc_block_size=1M --maximum-read_buffer_size=1M --maximum-read_rnd_buffer_size=1M --maximum-sort_buffer_size=1M --maximum-tmp_table_size=1M --maximum-transaction_alloc_block_size=1M --maximum-transaction_prealloc_size=1M --log-output=none --sql_mode=ONLY_FULL_GROUP_BY"  # See http://bugs.mysql.com/?id=73916 re: testing env setup
TRIALS=100000
ADD_RANDOM_OPTIONS=1  # Add random mysqld --options to MYEXTRA using an input file. 1=On, 0=off
MAX_NR_OF_RND_OPTS_TO_ADD=13  # Maximum number of random options to add (minimum is always 1)
VALGRIND_RUN=0  # Set to 1 to make this a Valgrind run
VALGRIND_CMD="valgrind --suppressions=${BASEDIR}/mysql-test/valgrind.supp --num-callers=40 --show-reachable=yes --track-origins=yes"
SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1  # Save only trials that generate a core file (good for initial few runs where there are lot of crashes/asserts)
SAVE_SQL=0  # If SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1, then this overwrites it as far as storing of SQL files goes. Reason: get SQL for full server lockups with no core or Valgrind generated. This way the lockups can possibly be recreated.
if [ ${VALGRIND_RUN} -eq 1 ]; then
  MYSQLD_START_TIMEOUT=300
else
  MYSQLD_START_TIMEOUT=60
fi
ARCHIVE_INFILE_COPY=1  # Archive a copy of the SQL input file in the work directory
PXC_DOCKER_START_TIMEOUT=140
MULTI_THREADED_RUN=0  # Set to 0 for a single-thread client run only, or set to 1 for a multi threaded run. You can still change options below if you like, but this is an easy if/then "profile" shortcut that pre-sets optimal settings for single or multi threaded runs. So, this variables is _only_ used in the next IF.
if [ ${MULTI_THREADED_RUN} -eq 0 ]; then
  # Suggestion: keep PQUERY_RUN_TIMEOUT low for the moment (10 to 240 seconds) - even in 10-20 seconds pquery can execute thousands of queries == more crashes
  if [ ${PXC} -eq 1 ]; then
    PQUERY_RUN_TIMEOUT=120  # See below for run time timeout descripton. Starting up a cluster takes more time, so don't rotate too quickly
    QUERIES_PER_THREAD=2147483647  # Max int
  else
    PQUERY_RUN_TIMEOUT=15  # x seconds max pquery trial run time (in this it will try to process ${QUERIES_PER_THREAD} x ${THREADS} queries against 1 mysqld)
    QUERIES_PER_THREAD=100000
  fi
  THREADS=1
  MULTI_THREADED_TESTC_LINES=0  # Not used for single threaded-runs
else
  # Suggestion: keep PQUERY_RUN_TIMEOUT low for the moment (10 to 240 seconds) - even in 10-20 seconds pquery can execute thousands of queries == more crashes
  if [ ${PXC} -eq 1 ]; then
    PQUERY_RUN_TIMEOUT=120  # See below for run time timeout descripton. Starting up a cluster takes more time, so don't rotate too quickly
    QUERIES_PER_THREAD=2147483647  # Max int
  else
    PQUERY_RUN_TIMEOUT=30  # x seconds max pquery trial run time (in this it will try to process ${QUERIES_PER_THREAD} x ${THREADS} queries against 1 mysqld)
    QUERIES_PER_THREAD=100000
  fi
  THREADS=30
  MULTI_THREADED_TESTC_LINES=25000  # Only takes effect if THREADS>1. pquery-run will take this amount of lines to form individual testcases for mutli-threaded runs. IOW, if THREADS=1, pquery-run will just run one client, continously getting random queries out of INFILE, uptill QUERIES_PER_THREAD queries is reached (if mysqld does not crash earlier). On the other hand, if THREADS>1, then pquery-run will take a random chunk out of INFILE (to the amount of MULTI_THREADED_TESTC_LINES lines) _before_ starting it's pquery run. It will then run pquery, with THREADS threads, only using that smaller chunk extracted from INFILE. So, if MULTI_THREADED_TESTC_LINES=1000, and THREADS=100 and INFILE=main-new.sql, then it will grab 1000 random lines out of main-new.sql, create a new temporary (and stored/saved in the trial's dir) sql file from these 10 lines, start mysqld and use pquery to run 100 parallel client threads against it, utill the maximum amount of queries (i.e QUERIES_PER_THREAD) for each threads is reached (if mysqld does not crash earlier).
fi
if [ ${VALGRIND_RUN} -eq 1 ]; then
  PQUERY_RUN_TIMEOUT=$[ ${PQUERY_RUN_TIMEOUT} + 180 ]  # Make sure run time is at least 180 seconds for a Valgrind runs (Valgrind is very slow)
fi

# Setup counters
SAVED=0
TRIAL=0

# Trap ctrl-c 
trap ctrl-c SIGINT

ctrl-c(){
  echoit "CTRL+C Was pressed. Attempting to terminate running processes..."
  KILL_PIDS=`ps -ef | grep "$RANDOMD" | grep -v "grep" | awk '{print $2}' | tr '\n' ' '`
  if [ "${KILL_PIDS}" != "" ]; then
    echoit "Terminating the following PID's: ${KILL_PIDS}"
    kill -9 ${KILL_PIDS} >/dev/null 2>&1
  fi
  if [ -d ${RUNDIR}/${TRIAL}/ ]; then
    echoit "Done. Moving the trial $0 was currently working on to workdir as ${WORKDIR}/${TRIAL}/..."
    mv ${RUNDIR}/${TRIAL}/ ${WORKDIR}/
  fi
  echoit "Attempting to cleanup the pquery rundir ${RUNDIR}..."
  rm -Rf ${RUNDIR}
  if [ $SAVED -eq 0 -a ${SAVE_SQL} -eq 0 ]; then
    echoit "There were no coredumps saved, and SAVE_SQL=0, so the workdir can be safely deleted. Doing so..."
    rm -Rf ${WORKDIR}
  else
    echoit "The results of this run can be found in the workdir ${WORKDIR}..."
  fi
  echoit "Done. Terminating pquery-run.sh with exit code 2..."
  exit 2
}

if [ -r ${BASEDIR}/bin/mysqld ]; then
  BIN=${BASEDIR}/bin/mysqld
else
  # Check if this is a debug build by checking if debug string is present in dirname
  if [[ ${BASEDIR} = *debug* ]]; then
    if [ -r ${BASEDIR}/bin/mysqld-debug ]; then
      BIN=${BASEDIR}/bin/mysqld-debug
    else
      echoit "Something is wrong: there is no (script readable) mysqld binary at ${BASEDIR}/bin/mysqld[-debug] ?"
      exit 1
    fi
  else
    echoit "Something is wrong: there is no (script readable) mysqld binary at ${BASEDIR}/bin/mysqld ?"
    exit 1
  fi
fi

savetrial(){
  if [ ${PXC} -eq 0 ]; then
    if [ -f ${RUNDIR}/${TRIAL}/data/*core* -o ${SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY} -eq 0 ]; then
      SAVED=$[ $SAVED + 1 ]
      echoit "Copying rundir from ${RUNDIR}/${TRIAL} to ${WORKDIR}/${TRIAL}"
      mv ${RUNDIR}/${TRIAL}/ ${WORKDIR}/
    else
      echoit "Could not generate core dump : Deleting rundir ${RUNDIR}/${TRIAL}"
      rm -Rf ${RUNDIR}/${TRIAL}
    fi
  else
    if [ $(ls -l ${RUNDIR}/${TRIAL}/*/*core.* 2>/dev/null | wc -l) -ge 1 ]; then
      SAVED=$[ $SAVED + 1 ]
      echoit "Copying rundir from ${RUNDIR}/${TRIAL} to ${WORKDIR}/${TRIAL}"
      mv ${RUNDIR}/${TRIAL}/ ${WORKDIR}/
    else
      echoit "Could not generate core dump : Deleting rundir ${RUNDIR}/${TRIAL}"
      rm -Rf ${RUNDIR}/${TRIAL}
    fi
  fi
}

savesql(){
  echoit "Copying sql trace(s) from ${RUNDIR}/${TRIAL} to ${WORKDIR}/${TRIAL}"
  mkdir ${WORKDIR}/${TRIAL}
  cp ${RUNDIR}/${TRIAL}/*.sql ${WORKDIR}/${TRIAL}/
  rm -Rf ${RUNDIR}/${TRIAL}
  sync; sleep 0.2
  if [ -d ${RUNDIR}/${TRIAL} ]; then
    echoit "Something is wrong: tried to remove ${RUNDIR}/${TRIAL}, but it looks like removal failed. Check what is holding lock? (lsof tool may help)."
    echoit "As this is not necessarily a fatal error (there is likely enough space on ${RUNDIR} to continue working), pquery-run.sh will NOT terminate."
    echoit "However, this looks like a shortcoming in pquery-run.sh (likely in the mysqld termination code) which needs debugging and fixing. Please do."
  fi
}

pquery_test(){
  TRIAL=$[ ${TRIAL} + 1 ]
  echoit "====== TRIAL #${TRIAL} ======"
  if [ ${PXC} -eq 0 ]; then
    echoit "Ensuring there are no relevant servers running..."
    KILLPID=$(ps -ef | grep "${RUNDIR}" | grep -v grep | awk '{print $2}' | tr '\n' ' ')
    (sleep 0.2; kill -9 $KILLPID >/dev/null 2>&1; wait $KILLPID >/dev/null 2>&1) &
    wait $KILLDPID >/dev/null 2>&1  # The sleep 0.2 + subsequent wait (cought before the kill) avoids the annoying 'Killed' message 
                                    # from being displayed in the output. Thank you to user 'Foonly' @ forums.whirlpool.net.au
  else
    echoit "Ensuring there are no relevant Docker containers present..."
    if [ ! -r ${DOCKER_COMPOSE_LOC}/cleanup.sh ]; then
      echoit "Assert: ${DOCKER_COMPOSE_LOC}/cleanup.sh was not found!"
      exit 1
    else
      ${DOCKER_COMPOSE_LOC}/cleanup.sh
    fi
  fi
  echoit "Clearing rundir..."
  rm -Rf ${RUNDIR}/*
  echoit "Generating new trial workdir ${RUNDIR}/${TRIAL}..."
  CANSTART=0
  if [ ${PXC} -eq 0 ]; then
    mkdir -p ${RUNDIR}/${TRIAL}/data/test ${RUNDIR}/${TRIAL}/data/mysql ${RUNDIR}/${TRIAL}/tmp ${RUNDIR}/${TRIAL}/log
    echoit "Copying datadir from template..."
    if [ `ls -l ${WORKDIR}/data.template/* | wc -l` -eq 0 ]; then
      echoit "Assert: ${WORKDIR}/data.template/ is empty? Check ${WORKDIR}/log/mysql_install_db.txt to see if the original template creation worked ok. Terminating."
      echoit "Note that this is can be caused by not having perl-Data-Dumper installed (sudo yum install perl-Data-Dumper), which is required for mysql_install_db."
      exit 1
    fi
    cp -R ${WORKDIR}/data.template/* ${RUNDIR}/${TRIAL}/data
    MYEXTRA_SAVE_IT=${MYEXTRA}
    if [ ${ADD_RANDOM_OPTIONS} -eq 1 ]; then  # Add random mysqld --options to MYEXTRA
      OPTIONS_TO_ADD=
      NR_OF_OPTIONS_TO_ADD=$(( RANDOM % MAX_NR_OF_RND_OPTS_TO_ADD + 1 ))
      for X in $(seq 1 ${NR_OF_OPTIONS_TO_ADD}); do
        OPTION_TO_ADD="$(shuf --random-source=/dev/urandom ${OPTIONS_INFILE} | head -n1)"
        if [ "$(echo ${OPTION_TO_ADD} | sed 's| ||g;s|.*query.alloc.block.size=1125899906842624.*||' )" != "" ]; then  # http://bugs.mysql.com/bug.php?id=78238
          OPTIONS_TO_ADD="${OPTIONS_TO_ADD} ${OPTION_TO_ADD}"
        fi
      done
      echoit "ADD_RANDOM_OPTIONS=1: adding option(s) ${OPTIONS_TO_ADD} to this run's MYEXTRA..."
      MYEXTRA="${MYEXTRA} ${OPTIONS_TO_ADD}"
    fi
    echo "${MYEXTRA}" | if grep -qi "innodb[_-]log[_-]checksum[_-]algorithm"; then
      # Ensure that mysqld server startup will not fail due to a mismatched checksum algo between the original MID and the changed MYEXTRA options
      rm ${RUNDIR}/${TRIAL}/data/ib_log*
    fi
    PORT=$[50000 + ( $RANDOM % ( 9999 ) ) ]
    echoit "Starting mysqld. Error log is stored at ${RUNDIR}/${TRIAL}/log/master.err"
    if [ ${VALGRIND_RUN} -eq 0 ]; then
      CMD="${BIN} ${MYSAFE} ${MYEXTRA} --basedir=${BASEDIR} --datadir=${RUNDIR}/${TRIAL}/data --tmpdir=${RUNDIR}/${TRIAL}/tmp \
	--core-file --port=$PORT --pid_file=${RUNDIR}/${TRIAL}/pid.pid --socket=${RUNDIR}/${TRIAL}/socket.sock \
	--log-output=none --log-error=${RUNDIR}/${TRIAL}/log/master.err"
    else
      CMD="${VALGRIND_CMD} ${BIN} ${MYSAFE} ${MYEXTRA} --basedir=${BASEDIR} --datadir=${RUNDIR}/${TRIAL}/data --tmpdir=${RUNDIR}/${TRIAL}/tmp \
	--core-file --port=$PORT --pid_file=${RUNDIR}/${TRIAL}/pid.pid --socket=${RUNDIR}/${TRIAL}/socket.sock \
	--log-output=none --log-error=${RUNDIR}/${TRIAL}/log/master.err"
    fi
    $CMD > ${RUNDIR}/${TRIAL}/log/master.err 2>&1 &
    MPID="$!"
    echo "$CMD > ${RUNDIR}/${TRIAL}/log/master.err 2>&1" > ${RUNDIR}/${TRIAL}/start; chmod +x ${RUNDIR}/${TRIAL}/start
    # New MYEXTRA/MYSAFE variables pass & VALGRIND run check method as of 2015-07-28 (MYSAFE & MYEXTRA stored in a text file inside the trial dir, VALGRIND file created if used)
    echo "${MYSAFE} ${MYEXTRA}" > ${RUNDIR}/${TRIAL}/MYEXTRA
    if [ ${VALGRIND_RUN} -eq 1 ]; then
      touch  ${RUNDIR}/${TRIAL}/VALGRIND
    fi
    # Restore orignal MYEXTRA for the next trial (MYEXTRA is no longer needed anywhere else. If this changes in the future, relocate this to below the changed code)
    MYEXTRA=${MYEXTRA_SAVE_IT}  
    # Give up to x (start timeout) seconds for mysqld to start, but check intelligently for known startup issues like "Error while setting value" for options
    if [ ${VALGRIND_RUN} -eq 0 ]; then
      echoit "Waiting for mysqld (pid: ${MPID}) to fully start..."
    else
      echoit "Waiting for mysqld (pid: ${MPID}) to fully start (note this is slow for Valgrind runs, and can easily take 35-90 seconds even on an high end server)..."
    fi
    BADVALUE=0
    for X in $(seq 0 ${MYSQLD_START_TIMEOUT}); do
      sleep 1
      if ${BASEDIR}/bin/mysqladmin -uroot -S${RUNDIR}/${TRIAL}/socket.sock ping > /dev/null 2>&1; then
        break
      fi
      if [ "${MPID}" == "" ]; then
        echoit "Assert! ${MPID} empty. Terminating!"
        exit 1
      fi
      if grep -qi "ERROR. Aborting" ${RUNDIR}/${TRIAL}/log/master.err; then
        if grep -qi "TCP.IP port. Address already in use" ${RUNDIR}/${TRIAL}/log/master.err; then
          echoit "Assert! The text '[ERROR] Aborting' was found in the error log due to a IP port conflict (the port was already in use)"
          savetrial
        else
          if [ ${ADD_RANDOM_OPTIONS} -eq 0 ]; then  # Halt for ADD_RANDOM_OPTIONS=0 runs, they should not produce errors like these, as MYEXTRA should be high-quality/non-faulty
            echoit "Assert! '[ERROR] Aborting' was found in the error log. This is likely an issue with one of the \$MEXTRA (or \$MYSAFE) startup parameters. Saving trial for further analysis, and dumping error log here for quick analysis. Please check the output against the \$MYEXTRA (or \$MYSAFE if it was modified) settings. You may also want to try setting \$MYEXTRA=\"\"..."
            grep "ERROR" ${RUNDIR}/${TRIAL}/log/master.err | tee /${WORKDIR}/pquery-run.log
            savetrial
            echoit "Remember to cleanup/delete the rundir:  rm -Rf ${RUNDIR}"
            exit 1
          else  # Do not halt for ADD_RANDOM_OPTIONS=1 runs, they are likely to produce errors like these as MYEXTRA was randomly changed
            echoit "'[ERROR] Aborting' was found in the error log. This is likely an issue with one of the MYEXTRA startup parameters. As ADD_RANDOM_OPTIONS=1, this is likely to be encountered. Not saving trial. If you see this error for every trial however, set \$ADD_RANDOM_OPTIONS=0 & try running pquery-run.sh again. If it still fails, your base \$MYEXTRA setting is faulty."
            grep "ERROR" ${RUNDIR}/${TRIAL}/log/master.err | tee /${WORKDIR}/pquery-run.log
            break
          fi
        fi
      fi
    done
    # Check if mysqld is alive and if so, start pquery run below
    if ${BASEDIR}/bin/mysqladmin -uroot -S${RUNDIR}/${TRIAL}/socket.sock ping > /dev/null 2>&1; then
      CANSTART=1
      echoit "Server started ok. Client:  `echo ${BIN} | sed 's|/mysqld|/mysql|'` -uroot -S${RUNDIR}/${TRIAL}/socket.sock"
    fi
  else
    mkdir -p ${RUNDIR}/${TRIAL}/
    chmod 777 -R ${RUNDIR} 
    echoit "Copying docker-compose file (${DOCKER_COMPOSE_YML}) to trial workdir ${RUNDIR}/${TRIAL}"
    if [ ! -r ${DOCKER_COMPOSE_YML} ]; then
      echoit "Assert: ${DOCKER_COMPOSE_YML} not found? Terminating."
      exit 1
    else
      cp ${DOCKER_COMPOSE_YML} ${RUNDIR}/${TRIAL} 
    fi

    # Adding random PXC wsrep related mysqld options to MYEXTRA 
    MYEXTRA_SAVE_IT=${MYEXTRA}
    if [ ${ADD_RANDOM_OPTIONS} -eq 1 ]; then  # Add random mysqld --options to MYEXTRA
      OPTIONS_TO_ADD=
      NR_OF_OPTIONS_TO_ADD=$(( RANDOM % MAX_NR_OF_RND_OPTS_TO_ADD + 1 ))
      for X in $(seq 1 ${NR_OF_OPTIONS_TO_ADD}); do
        OPTION_TO_ADD="$(shuf --random-source=/dev/urandom ${PXC_OPTIONS_INFILE} | head -n1)"
        OPTIONS_TO_ADD="${OPTIONS_TO_ADD} ${OPTION_TO_ADD}"
      done
      echoit "ADD_RANDOM_OPTIONS=1: adding option(s) ${OPTIONS_TO_ADD} to this run's MYEXTRA..."
      MYEXTRA=" ${MYEXTRA} ${OPTIONS_TO_ADD} --log-error=error.log"
      sed -i "s|--log-error=error.log|${MYEXTRA}|" ${RUNDIR}/${TRIAL}/docker-compose.yml
    fi

    echoit "Changing ${RUNDIR}/${TRIAL}/docker-compose.yml to use this trial's path (${RUNDIR}/${TRIAL})..."
    sed -i "s|/dev/shm/pxc-pquery|${RUNDIR}/${TRIAL}|" ${RUNDIR}/${TRIAL}/docker-compose.yml
    echoit "Starting 3 node PXC Cluster..."
    CURPATH=$PWD
    cd ${RUNDIR}/${TRIAL}
    sudo docker-compose up &
    cd ${CURPATH}; CURPATH=
    echoit "Waiting for the 3 node PXC Cluster to fully start..."
    for X in $(seq 0 ${PXC_DOCKER_START_TIMEOUT}); do
      sleep 1
      CLUSTER_UP=0;
      if ${BASEDIR}/bin/mysqladmin -uroot -h127.0.0.1 -P12000 ping > /dev/null 2>&1; then
        if [ `${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P10000 -e"show global status like 'wsrep_cluster_size'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_cluster" | awk '{print $2}'` -eq 3 ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
        if [ `${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P11000 -e"show global status like 'wsrep_cluster_size'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_cluster" | awk '{print $2}'` -eq 3 ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
        if [ `${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P12000 -e"show global status like 'wsrep_cluster_size'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_cluster" | awk '{print $2}'` -eq 3 ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
        if [ "`${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P10000 -e"show global status like 'wsrep_local_state_comment'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_local" | awk '{print $2}'`" == "Synced" ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
        if [ "`${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P11000 -e"show global status like 'wsrep_local_state_comment'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_local" | awk '{print $2}'`" == "Synced" ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
        if [ "`${BASEDIR}/bin/mysql -uroot -h127.0.0.1 -P12000 -e"show global status like 'wsrep_local_state_comment'" | sed 's/[| \t]\+/\t/g' | grep "wsrep_local" | awk '{print $2}'`" == "Synced" ]; then CLUSTER_UP=$[ ${CLUSTER_UP} + 1]; fi
      fi
      # If count reached 6 (there are 6 checks), then the Cluster is up & running and consistent in it's Cluster topology views (as seen by each node)
      if [ ${CLUSTER_UP} -eq 6 ]; then
        CANSTART=1
        echoit "3 Node PXC Cluster started ok. Clients:"
        echoit "Node #1: `echo ${BIN} | sed 's|/mysqld|/mysql|'` -uroot -h127.0.0.1 -P10000"
        echoit "Node #2: `echo ${BIN} | sed 's|/mysqld|/mysql|'` -uroot -h127.0.0.1 -P11000"
        echoit "Node #3: `echo ${BIN} | sed 's|/mysqld|/mysql|'` -uroot -h127.0.0.1 -P12000"
        break
      fi
    done
  fi
 
  if [ ${CANSTART} -eq 1 ]; then
    echoit "Starting pquery (log stored in ${RUNDIR}/${TRIAL}/pquery.log)..."
    export LD_LIBRARY_PATH=${BASEDIR}/lib  # Assuming here that pquery was correctly compiled with correct client lib
    if [ ${THREADS} -eq 1 ]; then  # Single-threaded run (1 client only)
      if [ ${PXC} -eq 0 ]; then
        ${PQUERY_BIN} --infile=${INFILE} --database=test --threads=${THREADS} --queries_per_thread=${QUERIES_PER_THREAD} --logdir=${RUNDIR}/${TRIAL} --log_all_queries --log_failed_queries --user=root --socket=${RUNDIR}/${TRIAL}/socket.sock >${RUNDIR}/${TRIAL}/pquery.log 2>&1 &
      else
        ${PQUERY_BIN} --infile=${INFILE} --database=test --threads=${THREADS} --queries_per_thread=${QUERIES_PER_THREAD} --logdir=${RUNDIR}/${TRIAL} --log_all_queries --log_failed_queries --user=root --addr=127.0.0.1 --port=10000 >${RUNDIR}/${TRIAL}/pquery.log 2>&1 &
      fi
    else  # Multi-threaded run using a chunk from INFILE (${THREADS} clients)
      echoit "Taking ${MULTI_THREADED_TESTC_LINES} lines randomly from ${INFILE} as testcase for this trial..."
      shuf ${INFILE} | head -n${MULTI_THREADED_TESTC_LINES} > ${RUNDIR}/${TRIAL}/${TRIAL}.sql
      # Debug echo "-------"; cat ${RUNDIR}/${TRIAL}/${TRIAL}.sql; echo "-------"
      if [ ${PXC} -eq 0 ]; then
        ${PQUERY_BIN} --infile=${RUNDIR}/${TRIAL}/${TRIAL}.sql --database=test --threads=${THREADS} --queries_per_thread=${QUERIES_PER_THREAD} --logdir=${RUNDIR}/${TRIAL} --log_all_queries --log_failed_queries --user=root --socket=${RUNDIR}/${TRIAL}/socket.sock >${RUNDIR}/${TRIAL}/pquery.log 2>&1 &
      else
        ${PQUERY_BIN} --infile=${RUNDIR}/${TRIAL}/${TRIAL}.sql --database=test --threads=${THREADS} --queries_per_thread=${QUERIES_PER_THREAD} --logdir=${RUNDIR}/${TRIAL} --log_all_queries --log_failed_queries --user=root --addr=127.0.0.1 --port=10000 >${RUNDIR}/${TRIAL}/pquery.log 2>&1 &
      fi
    fi 
    PQPID="$!"
    echoit "pquery running (Max duration: ${PQUERY_RUN_TIMEOUT}s)..."
    for X in $(seq 0 ${PQUERY_RUN_TIMEOUT}); do
      if grep -qi "error while loading shared libraries" ${RUNDIR}/${TRIAL}/pquery.log; then
        echoit "Assert: There was an error loading shared libraries for pquery (ref. ${RUNDIR}/${TRIAL}/pquery.log). The solution is to ensure that LD_LIBRARY_PATH is set correctly (this is normally done by this scripti, and it's currently set to LD_LIBRARY_PATH=${LD_LIBRARY_PATH}. Is this correct? Are the client libraries available at this location? Alternatively, compile the pquery binary with client libs included etc., see ${SCRIPT_PWD}/pquery/compile* scripts."
      fi
      Y=$X
      sleep 1
      if [ "`ps -ef | grep ${PQPID} | grep -v grep`" == "" ]; then  # pquery ended
        break
      fi
    done
    if [ $Y -eq ${PQUERY_RUN_TIMEOUT} ]; then 
      echoit "${PQUERY_RUN_TIMEOUT}s timeout reached. Terminating this trial..."
    fi
    echoit "Cleaning up & saving results as needed..."
    TRIAL_SAVED=0;
    sleep 2  # Delay to ensure core was written completely (if any)
    if [ ${PXC} -eq 0 ]; then
      if [ ${VALGRIND_RUN} -eq 1 ]; then # For Valgrind, we want the full Valgrind output in the error log, hence we need a proper/clean (and slow...) shutdown
        # Note that even if mysqladmin is killed with the 'timeout --signal=9', it will not affect the actual state of mysqld, all that was terminated was mysqladmin. 
        # Thus, mysqld would have received a shutdown signal (even if the timeout was 2 seconds it would have)
        timeout --signal=9 20s ${BASEDIR}/bin/mysqladmin -uroot -S${RUNDIR}/${TRIAL}/socket.sock shutdown > /dev/null 2>&1  # Proper/clean shutdown attempt (up to 20 sec wait), necessary to get full Valgrind output in error log
        VALGRIND_SUMMARY_FOUND=0
        for X in $(seq 0 600); do  # Wait for full Valgrind output in error log
          sleep 1
          if [ ! -r ${RUNDIR}/${TRIAL}/log/master.err ]; then
            echoit "Assert: ${RUNDIR}/${TRIAL}/log/master.err not found during a Valgrind run. Please check. Trying to continue, but something is wrong already..."
            break
          elif egrep -qi "==[0-9]+== ERROR SUMMARY: [0-9]+ error" ${RUNDIR}/${TRIAL}/log/master.err; then  # Summary found, Valgrind is done
            VALGRIND_SUMMARY_FOUND=1
            sleep 2
            break
          fi
        done
        if [ ${VALGRIND_SUMMARY_FOUND} -eq 0 ]; then
          kill -9 ${PQPID} >/dev/null 2>&1;
          kill -9 ${MPID} >/dev/null 2>&1;
          sleep 2  # <^ Make sure mysqld is gone
          echoit "Odd mysqld hang detected (mysqld did not terminate even after 600 seconds), saving this trial... "
          if [ ${TRIAL_SAVED} -eq 0 ]; then
            savetrial
            TRIAL_SAVED=1
          fi
        fi
      else
        timeout --signal=9 20s ${BASEDIR}/bin/mysqladmin -uroot -S${RUNDIR}/${TRIAL}/socket.sock shutdown > /dev/null 2>&1  # Proper/clean shutdown attempt (up to 20 sec wait), may catch shutdown bugs
        sleep 2
      fi
      (sleep 0.2; kill -9 ${MPID} >/dev/null 2>&1; wait ${MPID} >/dev/null 2>&1) &  # Terminate mysqld
      wait ${MPID} >/dev/null 2>&1
      (sleep 0.2; kill -9 ${PQPID} >/dev/null 2>&1; wait ${PQPID} >/dev/null 2>&1) &  # Terminate pquery (if it went past ${PQUERY_RUN_TIMEOUT} time)
      wait ${PQPID} >/dev/null 2>&1
      kill -9 ${PQPID} >/dev/null 2>&1;
      kill -9 ${MPID} >/dev/null 2>&1;
      sleep 2  # <^ Make sure mysqld is gone
    else
      ${SCRIPT_PWD}/pxc-pquery/cleanup.sh
      echoit "Changing owner of trial workdir (${RUNDIR}/${TRIAL}) to `whoami`:`whoami`..."
      sudo chown -R `whoami`:`whoami` ${RUNDIR}/${TRIAL}
    fi
    echoit "`cat "${RUNDIR}/${TRIAL}/pquery.log" | grep -i 'SUMMARY' | sed 's|^.*:|pquery summary:|'`"
    if [ ${VALGRIND_RUN} -eq 1 ]; then
      VALGRIND_ERRORS_FOUND=0
      # What follows next are 3 different ways of checking if Valgrind issues were seen, mostly to ensure that no Valgrind issues go unseen, especially if log is not complete
      VALGRIND_CHECK_1=$(grep "==[0-9]\+== ERROR SUMMARY: [0-9]\+ error" ${RUNDIR}/${TRIAL}/log/master.err | sed 's|.*ERROR SUMMARY: \([0-9]\+\) error.*|\1|')
      if [ "${VALGRIND_CHECK_1}" == "" ]; then VALGRIND_CHECK_1=0; fi
      if [ ${VALGRIND_CHECK_1} -gt 0 ]; then 
        VALGRIND_ERRORS_FOUND=1; 
      fi
      if egrep -qi "^[ \t]*==[0-9]+[= \t]+[atby]+[ \t]*0x" ${RUNDIR}/${TRIAL}/log/master.err; then 
        VALGRIND_ERRORS_FOUND=1; 
      fi
      if egrep -qi "==[0-9]+== ERROR SUMMARY: [1-9]" ${RUNDIR}/${TRIAL}/log/master.err; then 
        VALGRIND_ERRORS_FOUND=1; 
      fi
      if [ ${VALGRIND_ERRORS_FOUND} -eq 1 ]; then
        VALGRIND_TEXT=`${SCRIPT_PWD}/valgrind_string.sh ${RUNDIR}/${TRIAL}/log/master.err`
        echoit "Valgrind error detected: ${VALGRIND_TEXT}"
        if [ ${TRIAL_SAVED} -eq 0 ]; then
          savetrial
          TRIAL_SAVED=1
        fi
      else
        # Report that no Valgrnid errors were found & Include ERROR SUMMARY from error log
        echoit "No Valgrind errors detected. $(grep "==[0-9]\+== ERROR SUMMARY: [0-9]\+ error" ${RUNDIR}/${TRIAL}/log/master.err | sed 's|.*ERROR S|ERROR S|')"
      fi
    fi
    if [ $(ls -l ${RUNDIR}/${TRIAL}/*/*core.* 2>/dev/null | wc -l) -ge 1 ]; then
      echoit "mysqld coredump detected at $(ls ${RUNDIR}/${TRIAL}/*/*core.*)"
      if [ ${PXC} -eq 0 ]; then
        echoit "Bug found (as per error log): `${SCRIPT_PWD}/text_string.sh ${RUNDIR}/${TRIAL}/log/master.err`"
      else
        CORE1=`ls ${RUNDIR}/${TRIAL}/1/*core.* 2>/dev/null`
        CORE2=`ls ${RUNDIR}/${TRIAL}/2/*core.* 2>/dev/null`
        CORE3=`ls ${RUNDIR}/${TRIAL}/3/*core.* 2>/dev/null`
        if [ ! "${CORE1}" == "" ]; then echoit "Bug found in PXC node #1 (as per error log): `${SCRIPT_PWD}/text_string.sh ${CORE1}`"; fi
        if [ ! "${CORE2}" == "" ]; then echoit "Bug found in PXC node #2 (as per error log): `${SCRIPT_PWD}/text_string.sh ${CORE2}`"; fi
        if [ ! "${CORE3}" == "" ]; then echoit "Bug found in PXC node #3 (as per error log): `${SCRIPT_PWD}/text_string.sh ${CORE3}`"; fi
      fi
      if [ ${TRIAL_SAVED} -eq 0 ]; then
        savetrial
        TRIAL_SAVED=1
      fi
    elif [ ${SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY} -eq 0 ]; then
      if [ ${TRIAL_SAVED} -eq 0 ]; then
        echoit "Saving full trial outcome (as SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=0 and so trials are saved irrespective of whetter an issue was detected or not)"
        savetrial
        TRIAL_SAVED=1
      fi
    else
      if [ ${SAVE_SQL} -eq 1 ]; then 
        if [ ${VALGRIND_RUN} -eq 1 ]; then
          echoit "Not saving anything for this trial (as SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1, and no coredump or Valgrind issue was generated), except the SQL trace (as SAVE_SQL=1)"
        else
          echoit "Not saving anything for this trial (as SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1, and no coredump was generated), except the SQL trace (as SAVE_SQL=1)"
        fi
        savesql
      else
        if [ ${VALGRIND_RUN} -eq 1 ]; then
          echoit "Not saving anything for this trial (as SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1 as well as SAVE_SQL=0, and no coredump or Valgrind issue was generated)" 
        else
          echoit "Not saving anything for this trial (as SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY=1 as well as SAVE_SQL=0, and no coredump was generated)" 
        fi
      fi
    fi  
  else
    if [ ${PXC} -eq 0 ]; then
      echoit "Server (PID: ${MPID} | Socket: ${RUNDIR}/${TRIAL}/socket.sock) failed to start after ${MYSQLD_START_TIMEOUT} seconds. Will issue extra kill -9 to ensure it's gone..."
      (sleep 0.2; kill -9 ${MPID} >/dev/null 2>&1; wait ${MPID} 2>&1) &
      wait ${MPID} >/dev/null 2>&1
      sleep 2; sync
    else
      echoit "3 Node PXC Cluster failed to start after ${PXC_DOCKER_START_TIMEOUT} seconds. Will issue an extra cleanup to ensure nothing remains..."
      ${DOCKER_COMPOSE_LOC}/cleanup.sh
      sleep 2; sync
    fi
  fi
}

# Setup
rm -Rf ${WORKDIR} ${RUNDIR}
mkdir ${WORKDIR} ${WORKDIR}/log ${RUNDIR}
if [ ${PXC} -eq 0 ];then
  echoit "Workdir: ${WORKDIR} | Rundir: ${RUNDIR} | Basedir: ${BASEDIR}"
else
  echoit "Workdir: ${WORKDIR} | Rundir: ${RUNDIR} | Basedir: ${BASEDIR} | PXC Docker Mode: Active"
fi
echoit "mysqld Start Timeout: ${MYSQLD_START_TIMEOUT} | Client Threads: ${THREADS} | Queries/Thread: ${QUERIES_PER_THREAD} | Trials: ${TRIALS} | Save coredump/valgrind issue trials only: `if [ ${SAVE_TRIALS_WITH_CORE_OR_VALGRIND_ONLY} -eq 1 ]; then echo -n 'TRUE'; if [ ${SAVE_SQL} -eq 1 ]; then echo ' + save all SQL traces'; else echo ''; fi; else echo 'FALSE'; fi`"
echoit "Valgrind run: `if [ ${VALGRIND_RUN} -eq 1 ]; then echo -n 'TRUE'; else echo -n 'FALSE'; fi` | pquery timeout: ${PQUERY_RUN_TIMEOUT} | SQL file used: ${INFILE} `if [ ${THREADS} -ne 1 ]; then echo -n "| Testcase size (chunked from infile): ${MULTI_THREADED_TESTC_LINES}"; fi`"
echoit "pquery Binary: ${PQUERY_BIN}"
if [ "${MYEXTRA}" != "" ]; then echoit "MYEXTRA: ${MYEXTRA}"; fi
if [ "${MYSAFE}" != "" ]; then echoit "MYSAFE: ${MYSAFE}"; fi
echoit "Making a copy of the pquery binary used (${PQUERY_BIN}) to ${WORKDIR} (handy for later re-runs/reference etc.)"
cp ${PQUERY_BIN} ${WORKDIR}
echoit "Making a copy of this script (${SCRIPT}) to ${WORKDIR} for reference & adding pquery- prefix (avoids pquery-prep-run not finding the script)..."  # pquery- prefix avoids pquer-prep-red.sh script-locating issues if this script had been renamed to a name without 'pquery' in it.
cp ${SCRIPT_AND_PATH} ${WORKDIR}/pquery-${SCRIPT}
if [ ${ARCHIVE_INFILE_COPY} -eq 1 ]; then
  echoit "Making a copy of the SQL input file used (${INFILE}) to ${WORKDIR} for reference..."
  cp ${INFILE} ${WORKDIR}
fi

if [ "$(${BIN} --version | grep -oe '5\.[1567]' | head -n1)" == "5.7" ]; then
  if [[ ! `${BIN}  --version | grep -oe '5\.[1567]\.[0-5]'` ]]; then
    MID_OPT="--initialize-insecure"
  else
    MID_OPT="--insecure"
  fi
else
  MID_OPT="--force --no-defaults"
fi

if [ "${MID_OPT}" == "--initialize-insecure" ]; then
    MID_57="${BASEDIR}/bin/mysqld"
  else
    MID_57="${BASEDIR}/bin/mysql_install_db"
  fi

if [ ${PXC} -eq 0 ]; then
  echoit "Making a copy of the mysqld used to ${WORKDIR}/mysqld (handy for coredump analysis and manual bundle creation)..."  # Fig setup also does this for PXC elsewhere
  mkdir ${WORKDIR}/mysqld
  cp ${BIN} ${WORKDIR}/mysqld
  echoit "Making a copy of the ldd files required for mysqld core analysis to ${WORKDIR}/mysqld..."
  PWDTMPSAVE=$PWD
  cd ${WORKDIR}/mysqld
  ${SCRIPT_PWD}/ldd_files.sh  # TODO for PXC, not sure yet how
  cd ${PWDTMPSAVE}
  echoit "Generating datadir template (using mysql_install_db)..."
  if [ -r ${BASEDIR}/bin/mysql_install_db ]; then 
    $MID_57 $MID_OPT --basedir=${BASEDIR} --datadir=${WORKDIR}/data.template > ${WORKDIR}/log/mysql_install_db.txt 2>&1
  elif [ -r ${BASEDIR}/scripts/mysql_install_db ]; then 
    ${BASEDIR}/scripts/mysql_install_db $MID_OPT --basedir=${BASEDIR} --datadir=${WORKDIR}/data.template > ${WORKDIR}/log/mysql_install_db.txt 2>&1
  else 
    echoit "Error: mysql_install_db not found in $PWD/scripts nor in $PWD/bin"
    exit 1
  fi
  echo "${MYEXTRA}${MYSAFE}" | if grep -qi "innodb[_-]log[_-]checksum[_-]algorithm"; then
    # Ensure that if MID created log files with the standard checksum algo, whilst we start the server with another one, that log files are re-created by mysqld
    rm ${WORKDIR}/data.template/ib_log*
  fi
else
  echoit "Ensuring that PXC Docker Images are ready to go..."
  if [ $(sudo docker images | grep "dockercompose_pxc" | wc -l) -ne 3 ]; then
    echoit "Assert: $(sudo docker images | grep "new_pxc" | wc -l) != 3"
    echoit "Did you run cd ${DOCKER_COMPOSE_LOC}; sudo docker-compose up followed by CTRL+C when the cluster was fully up (takes about 5 minutes) ? Terminating."
    exit 1
  else
    echoit "Found 3 dockercompose_pxc images in place/ready to go, proceeding..."
  fi
fi

# Start actual pquery testing
echoit "Starting pquery testing iterations..."
COUNT=0
for X in $(seq 1 ${TRIALS}); do
  pquery_test
  COUNT=$[ $COUNT + 1 ]
done
# All done, wrap up pquery run
echoit "pquery finished requested number of trials (${TRIALS})... Terminating..."
if [ ${PXC} -eq 0 ]; then 
  echoit "Cleaning up any leftover processes..."
  KILL_PIDS=`ps -ef | grep "$RANDOMD" | grep -v "grep" | awk '{print $2}' | tr '\n' ' '`
  if [ "${KILL_PIDS}" != "" ]; then
    echoit "Terminating the following PID's: ${KILL_PIDS}"
    kill -9 ${KILL_PIDS} >/dev/null 2>&1
  fi
else
  echoit "Cleaning up remaining Docker containers..."
  ${DOCKER_COMPOSE_LOC}/cleanup.sh
fi
echoit "Done. Attempting to cleanup the pquery rundir ${RUNDIR}..."
rm -Rf ${RUNDIR}
echoit "The results of this run can be found in the workdir ${WORKDIR}..."
echoit "Done. Exiting $0 with exit code 0..."
exit 0
